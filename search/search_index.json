{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs \u00b6 For full documentation visit mkdocs.org . Nama : Ahmad Addin Wirayudha AA NIM : 180411100045 Prodi : Teknik Informatika Kelas : Komputasi Numerik - B MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"Index"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org . Nama : Ahmad Addin Wirayudha AA NIM : 180411100045 Prodi : Teknik Informatika Kelas : Komputasi Numerik - B MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"Welcome to MkDocs"},{"location":"1/","text":"Error in Numerical Computations \u00b6 Error/Galat merupakan perbedaan antara hasil penyelesaian suatu model matematik secara numeric dengan penyelesaian secara analitis. Absolute Error \u00b6 Kesalahan absolut suatu kuantitas adalah nilai absolut dari selisih antara nilai sebenarnya X dan nilai perkiraan x. Relatif Errors \u00b6 Relative error biasa disebut sebagai Kesalahan relatif dari suatu kuantitas adalah rasio kesalahan absolutnya terhadap nilai sebenarnya. Mc Laurin \u00b6 Adalah Suatu fungsi f(x) yang memiliki turunan , , , dan seterusnya yang kontinyu dalam interval dengan maka untuk disekitar yaitu , dapat diekspansi kedalam Deret Taylor Definisi. $$ f(x)\u2248f(0)+f\u2019(0)x \\displaystyle+\\frac{{{f}\\text{'}\\text{'}{\\left({0}\\right)}}}{{{2}!}}{x}^{2}+ 2! f\u2019\u2019(0) \u200b x 2 \\displaystyle+\\frac{{{f}\\text{'}\\text{'}\\text{'}{\\left({0}\\right)}}}{{{3}!}}{x}^{3}+ f\u2019\u2019\u2019(0) \u200b x 3 \\displaystyle+\\frac{{{{f}^{{\\text{iv}}}{\\left({0}\\right)}}}}{{{4}!}}{x}^{4} \\displaystyle+\\ldots $$ atau Perhitungan e^2x \u00b6 Dalam banyak masalah terapan, pilihan basis yang mudah digunakan adalah bilangan irasional e = 2,718281828... Bilangan ini disebut basis natural . Fungsi f ( x ) = ex disebut sebagai fungsi eksponensial natural. Gambar 7 menunjukkan grafik fungsi ini. Pastikan bahwa dalam melihat fungsi eksponensial f ( x ) = ex , e adalah konstanta 2,718281828\u2026, sedangkan x adalah variabel. $$ f(x)=e^x $$ f'(x) = ex f'(0) = 1 f\u201d(x) = ex f\u201d(0) = 1 f\u201d'(x) = ex f\u201d'(0) = 1 Untuk bilangan e^2x maka: jadi, kesimpulannya adalah sebagai berikut: ketika nilai x diganti dengan 4 maka hasilnya adalah 296,99. Listing Program \u00b6 Untuk membuat program agar dapat mengekspansi bilangan e^2x dengan nilai x=4 hingga nilai menjadi kurang dari 0,001 bisa dibuat dengan listing program sebagai berikut. import math x = 4 cek = 1 a = 0 b = 1 iter = 1 while cek > 0.001 : f_x = 0 f_y = 0 for i in range ( a ): f_x += ( 2 ** i ) * x ** i / math . factorial ( i ) for j in range ( b ): f_y += ( 2 ** j ) * x ** j / math . factorial ( j ) cek = f_y - f_x a += 1 b += 1 print ( \"iterasi ke-\" , iter , \"= \" , cek ) iter += 1 Output iterasi ke - 1 = 1.0 iterasi ke - 2 = 8.0 iterasi ke - 3 = 32.0 iterasi ke - 4 = 85.33333333333333 iterasi ke - 5 = 170.66666666666669 iterasi ke - 6 = 273.0666666666666 iterasi ke - 7 = 364.08888888888896 iterasi ke - 8 = 416.1015873015872 iterasi ke - 9 = 416.1015873015872 iterasi ke - 10 = 369.8680776014112 iterasi ke - 11 = 295.89446208112895 iterasi ke - 12 = 215.195972422639 iterasi ke - 13 = 143.46398161509296 iterasi ke - 14 = 88.28552714774924 iterasi ke - 15 = 50.448872655856576 iterasi ke - 16 = 26.90606541645684 iterasi ke - 17 = 13.45303270822842 iterasi ke - 18 = 6.330838921519444 iterasi ke - 19 = 2.8137061873417224 iterasi ke - 20 = 1.184718394670199 iterasi ke - 21 = 0.47388735786807956 iterasi ke - 22 = 0.18052851728316455 iterasi ke - 23 = 0.06564673355751438 iterasi ke - 24 = 0.022833646454728296 iterasi ke - 25 = 0.0076112154847578495 iterasi ke - 26 = 0.0024355889549951826 iterasi ke - 27 = 0.0007494119863622473 MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"Tugas 1"},{"location":"1/#error-in-numerical-computations","text":"Error/Galat merupakan perbedaan antara hasil penyelesaian suatu model matematik secara numeric dengan penyelesaian secara analitis.","title":"Error in Numerical Computations"},{"location":"1/#absolute-error","text":"Kesalahan absolut suatu kuantitas adalah nilai absolut dari selisih antara nilai sebenarnya X dan nilai perkiraan x.","title":"Absolute Error"},{"location":"1/#relatif-errors","text":"Relative error biasa disebut sebagai Kesalahan relatif dari suatu kuantitas adalah rasio kesalahan absolutnya terhadap nilai sebenarnya.","title":"Relatif Errors"},{"location":"1/#mc-laurin","text":"Adalah Suatu fungsi f(x) yang memiliki turunan , , , dan seterusnya yang kontinyu dalam interval dengan maka untuk disekitar yaitu , dapat diekspansi kedalam Deret Taylor Definisi. $$ f(x)\u2248f(0)+f\u2019(0)x \\displaystyle+\\frac{{{f}\\text{'}\\text{'}{\\left({0}\\right)}}}{{{2}!}}{x}^{2}+ 2! f\u2019\u2019(0) \u200b x 2 \\displaystyle+\\frac{{{f}\\text{'}\\text{'}\\text{'}{\\left({0}\\right)}}}{{{3}!}}{x}^{3}+ f\u2019\u2019\u2019(0) \u200b x 3 \\displaystyle+\\frac{{{{f}^{{\\text{iv}}}{\\left({0}\\right)}}}}{{{4}!}}{x}^{4} \\displaystyle+\\ldots $$ atau","title":"Mc Laurin"},{"location":"1/#perhitungan-e2x","text":"Dalam banyak masalah terapan, pilihan basis yang mudah digunakan adalah bilangan irasional e = 2,718281828... Bilangan ini disebut basis natural . Fungsi f ( x ) = ex disebut sebagai fungsi eksponensial natural. Gambar 7 menunjukkan grafik fungsi ini. Pastikan bahwa dalam melihat fungsi eksponensial f ( x ) = ex , e adalah konstanta 2,718281828\u2026, sedangkan x adalah variabel. $$ f(x)=e^x $$ f'(x) = ex f'(0) = 1 f\u201d(x) = ex f\u201d(0) = 1 f\u201d'(x) = ex f\u201d'(0) = 1 Untuk bilangan e^2x maka: jadi, kesimpulannya adalah sebagai berikut: ketika nilai x diganti dengan 4 maka hasilnya adalah 296,99.","title":"Perhitungan e^2x"},{"location":"1/#listing-program","text":"Untuk membuat program agar dapat mengekspansi bilangan e^2x dengan nilai x=4 hingga nilai menjadi kurang dari 0,001 bisa dibuat dengan listing program sebagai berikut. import math x = 4 cek = 1 a = 0 b = 1 iter = 1 while cek > 0.001 : f_x = 0 f_y = 0 for i in range ( a ): f_x += ( 2 ** i ) * x ** i / math . factorial ( i ) for j in range ( b ): f_y += ( 2 ** j ) * x ** j / math . factorial ( j ) cek = f_y - f_x a += 1 b += 1 print ( \"iterasi ke-\" , iter , \"= \" , cek ) iter += 1 Output iterasi ke - 1 = 1.0 iterasi ke - 2 = 8.0 iterasi ke - 3 = 32.0 iterasi ke - 4 = 85.33333333333333 iterasi ke - 5 = 170.66666666666669 iterasi ke - 6 = 273.0666666666666 iterasi ke - 7 = 364.08888888888896 iterasi ke - 8 = 416.1015873015872 iterasi ke - 9 = 416.1015873015872 iterasi ke - 10 = 369.8680776014112 iterasi ke - 11 = 295.89446208112895 iterasi ke - 12 = 215.195972422639 iterasi ke - 13 = 143.46398161509296 iterasi ke - 14 = 88.28552714774924 iterasi ke - 15 = 50.448872655856576 iterasi ke - 16 = 26.90606541645684 iterasi ke - 17 = 13.45303270822842 iterasi ke - 18 = 6.330838921519444 iterasi ke - 19 = 2.8137061873417224 iterasi ke - 20 = 1.184718394670199 iterasi ke - 21 = 0.47388735786807956 iterasi ke - 22 = 0.18052851728316455 iterasi ke - 23 = 0.06564673355751438 iterasi ke - 24 = 0.022833646454728296 iterasi ke - 25 = 0.0076112154847578495 iterasi ke - 26 = 0.0024355889549951826 iterasi ke - 27 = 0.0007494119863622473 MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"Listing Program"},{"location":"2/","text":"Numerical Solution of Algebraic and Transcendental Equation \u00b6 1. Mencari akar dengan cara Bisection \u00b6 Metode bisection adalah algoritma pencarian akar pada sebuah interval. Interval tersebut membagi dua bagian lalu memilih bagian mana yang mengandung akar dan bagian yang tidak mengandung akar dibuang. Hal ini dilakukan berulang-ulang hingga diperoleh akar persamaan atau mendekati akar persamaan. Metode ini berlaku ketika ingin memecahkan persamaan dengan merupakan fungsi kontinyu. def bisection ( f , a , b , N ): if f ( a ) * f ( b ) >= 0 : print ( \"Bisection method fails.\" ) return None a_n = a b_n = b for n in range ( 1 , N + 1 ): m_n = ( a_n + b_n ) / 2 f_m_n = f ( m_n ) if f ( a_n ) * f_m_n < 0 : a_n = a_n b_n = m_n elif f ( b_n ) * f_m_n < 0 : a_n = m_n b_n = b_n elif f_m_n == 0 : print ( \"Found exact solution.\" ) return m_n else : print ( \"Bisection method fails.\" ) return None return ( a_n + b_n ) / 2 f = lambda x : x ** 2 - 5 * x + 6 approx_phi = bisection ( f , 1 , 2.3 , 25 ) print ( approx_phi ) output 1.9999999985098835 2. Mencari akar dengan cara Newton-Rapshon \u00b6 Metode Newton-Raphson adalah metode pencarian akar suatu fungsi dengan pendekatan satu titik, dimana fungsi mempunyai turunan. Metode ini dianggap lebih mudah dari Metode Bagi-Dua (Bisection Method) karena metode ini menggunakan pendekatan satu titik sebagai titik awal, semakin dekat titik awal yang kita pilih dengan akar sebenarnya maka semakin cepat konvergen ke akarnya. def newton(f,Df,x0,epsilon,max_iter): xn = x0 for n in range(0,max_iter): fxn = f(xn) if abs(fxn) < epsilon: print('Found solution after',n,'iterations.') return xn Dfxn = Df(xn) if Dfxn == 0: print('Zero derivative. No solution found.') return None xn = xn - fxn/Dfxn print('Exceeded maximum iterations. No solution found.') return None p = lambda x: x**2 - 5*x + 6 Dp = lambda x: 2*x - 5 approx = newton(p,Dp,1,1e-3,10) print(approx) output Found solution after 4 iterations. 1.9999847409781035 3. Mencari akar dengan cara Secant \u00b6 Pada Metode Newton-Raphson memerlukan syarat wajib yaitu fungsi harus memiliki turunan ., sehingga syarat wajib ini dianggap sulit karena tidak semua fungsi bisa dengan mudah mencari turunannya. Oleh karena itu, muncul ide dari yaitu mencari persamaan yang ekivalen dengan rumus turunan fungsi. Ide ini lebih dikenal dengan nama Metode Secant. Ide dari metode ini yaitu menggunakan gradien garis yang melalui titik dan . def secant ( f , a , b , N ): if f ( a ) * f ( b ) >= 0 : print ( \"Secant method fails.\" ) return None a_n = a b_n = b for n in range ( 1 , N + 1 ): m_n = a_n - f ( a_n ) * ( b_n - a_n ) / ( f ( b_n ) - f ( a_n )) f_m_n = f ( m_n ) if f ( a_n ) * f_m_n < 0 : a_n = a_n b_n = m_n elif f ( b_n ) * f_m_n < 0 : a_n = m_n b_n = b_n elif f_m_n == 0 : print ( \"Found exact solution.\" ) return m_n else : print ( \"Secant method fails.\" ) return None return a_n - f ( a_n ) * ( b_n - a_n ) / ( f ( b_n ) - f ( a_n )) p = lambda x : x ** 2 - 5 * x + 6 approx = secant ( p , 1 , 2.4 , 20 ) print ( approx ) output 2.0000003178913373 4. Mencari akar dengan cara Regulasi Falsi \u00b6 Metode Regular Falsi adalah panduan konsep Metode Bagi-Dua dan Metode Secant dimana menggunakan konsep Metode Bagi-Dua karena dimulai dengan pemilihan dua titik awal dan sedemikian sehingga dan berlawanan tanda atau . Kemudian menggunakan konsep Metode Secant yaitu dengan menarik garis dari titik dan sedemikian sehingga garis berpotongan pada sumbu \u2013 dan memotong kurva atau grafik fungsi pada titik dan . Sehingga Metode Regular Falsi ini akan menghasilkan titik potong pada sumbu- yaitu yang merupakan calon akar dan tetap berada dalam interval . Metode ini kemudian berlanjut dengan menghasilkan berturut-turut interval yang semuanya berisi akar . error = 0.01 a = 0 b = 2.1 def f ( x ): return x ** 2 - 5 * x + 6 def regulasi_falsi ( a , b ): i = 0 max_iter = 50 iteration = True while iteration and i < max_iter : if f ( a ) * f ( b ) < 0 : x = ( a * abs ( f ( b )) + b * abs ( f ( a ))) / ( abs ( f ( a )) + abs ( f ( b ))) if f ( a ) * f ( x ) < 0 : b = x if f ( x ) * f ( b ) < 0 : a = x if abs ( a - b ) < error : iteration = False else : i += 1 else : print ( 'tidak di temukan akar' ) print ( 'x =' , x ) regulasi_falsi ( a , b ) output x = 2.000000000174259","title":"Tugas 2"},{"location":"2/#numerical-solution-of-algebraic-and-transcendental-equation","text":"","title":"Numerical Solution of Algebraic and Transcendental Equation"},{"location":"2/#1-mencari-akar-dengan-cara-bisection","text":"Metode bisection adalah algoritma pencarian akar pada sebuah interval. Interval tersebut membagi dua bagian lalu memilih bagian mana yang mengandung akar dan bagian yang tidak mengandung akar dibuang. Hal ini dilakukan berulang-ulang hingga diperoleh akar persamaan atau mendekati akar persamaan. Metode ini berlaku ketika ingin memecahkan persamaan dengan merupakan fungsi kontinyu. def bisection ( f , a , b , N ): if f ( a ) * f ( b ) >= 0 : print ( \"Bisection method fails.\" ) return None a_n = a b_n = b for n in range ( 1 , N + 1 ): m_n = ( a_n + b_n ) / 2 f_m_n = f ( m_n ) if f ( a_n ) * f_m_n < 0 : a_n = a_n b_n = m_n elif f ( b_n ) * f_m_n < 0 : a_n = m_n b_n = b_n elif f_m_n == 0 : print ( \"Found exact solution.\" ) return m_n else : print ( \"Bisection method fails.\" ) return None return ( a_n + b_n ) / 2 f = lambda x : x ** 2 - 5 * x + 6 approx_phi = bisection ( f , 1 , 2.3 , 25 ) print ( approx_phi ) output 1.9999999985098835","title":"1. Mencari akar dengan cara Bisection"},{"location":"2/#2-mencari-akar-dengan-cara-newton-rapshon","text":"Metode Newton-Raphson adalah metode pencarian akar suatu fungsi dengan pendekatan satu titik, dimana fungsi mempunyai turunan. Metode ini dianggap lebih mudah dari Metode Bagi-Dua (Bisection Method) karena metode ini menggunakan pendekatan satu titik sebagai titik awal, semakin dekat titik awal yang kita pilih dengan akar sebenarnya maka semakin cepat konvergen ke akarnya. def newton(f,Df,x0,epsilon,max_iter): xn = x0 for n in range(0,max_iter): fxn = f(xn) if abs(fxn) < epsilon: print('Found solution after',n,'iterations.') return xn Dfxn = Df(xn) if Dfxn == 0: print('Zero derivative. No solution found.') return None xn = xn - fxn/Dfxn print('Exceeded maximum iterations. No solution found.') return None p = lambda x: x**2 - 5*x + 6 Dp = lambda x: 2*x - 5 approx = newton(p,Dp,1,1e-3,10) print(approx) output Found solution after 4 iterations. 1.9999847409781035","title":"2. Mencari akar dengan cara Newton-Rapshon"},{"location":"2/#3-mencari-akar-dengan-cara-secant","text":"Pada Metode Newton-Raphson memerlukan syarat wajib yaitu fungsi harus memiliki turunan ., sehingga syarat wajib ini dianggap sulit karena tidak semua fungsi bisa dengan mudah mencari turunannya. Oleh karena itu, muncul ide dari yaitu mencari persamaan yang ekivalen dengan rumus turunan fungsi. Ide ini lebih dikenal dengan nama Metode Secant. Ide dari metode ini yaitu menggunakan gradien garis yang melalui titik dan . def secant ( f , a , b , N ): if f ( a ) * f ( b ) >= 0 : print ( \"Secant method fails.\" ) return None a_n = a b_n = b for n in range ( 1 , N + 1 ): m_n = a_n - f ( a_n ) * ( b_n - a_n ) / ( f ( b_n ) - f ( a_n )) f_m_n = f ( m_n ) if f ( a_n ) * f_m_n < 0 : a_n = a_n b_n = m_n elif f ( b_n ) * f_m_n < 0 : a_n = m_n b_n = b_n elif f_m_n == 0 : print ( \"Found exact solution.\" ) return m_n else : print ( \"Secant method fails.\" ) return None return a_n - f ( a_n ) * ( b_n - a_n ) / ( f ( b_n ) - f ( a_n )) p = lambda x : x ** 2 - 5 * x + 6 approx = secant ( p , 1 , 2.4 , 20 ) print ( approx ) output 2.0000003178913373","title":"3. Mencari akar dengan cara Secant"},{"location":"2/#4-mencari-akar-dengan-cara-regulasi-falsi","text":"Metode Regular Falsi adalah panduan konsep Metode Bagi-Dua dan Metode Secant dimana menggunakan konsep Metode Bagi-Dua karena dimulai dengan pemilihan dua titik awal dan sedemikian sehingga dan berlawanan tanda atau . Kemudian menggunakan konsep Metode Secant yaitu dengan menarik garis dari titik dan sedemikian sehingga garis berpotongan pada sumbu \u2013 dan memotong kurva atau grafik fungsi pada titik dan . Sehingga Metode Regular Falsi ini akan menghasilkan titik potong pada sumbu- yaitu yang merupakan calon akar dan tetap berada dalam interval . Metode ini kemudian berlanjut dengan menghasilkan berturut-turut interval yang semuanya berisi akar . error = 0.01 a = 0 b = 2.1 def f ( x ): return x ** 2 - 5 * x + 6 def regulasi_falsi ( a , b ): i = 0 max_iter = 50 iteration = True while iteration and i < max_iter : if f ( a ) * f ( b ) < 0 : x = ( a * abs ( f ( b )) + b * abs ( f ( a ))) / ( abs ( f ( a )) + abs ( f ( b ))) if f ( a ) * f ( x ) < 0 : b = x if f ( x ) * f ( b ) < 0 : a = x if abs ( a - b ) < error : iteration = False else : i += 1 else : print ( 'tidak di temukan akar' ) print ( 'x =' , x ) regulasi_falsi ( a , b ) output x = 2.000000000174259","title":"4. Mencari akar dengan cara Regulasi Falsi"}]}